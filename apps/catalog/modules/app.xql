xquery version "3.0";


module namespace app="http://bluemountain.princeton.edu/catalog/templates";

import module namespace templates="http://exist-db.org/xquery/templates" ;
import module namespace config="http://bluemountain.princeton.edu/catalog/config" at "config.xqm";

declare namespace mets="http://www.loc.gov/METS/";
declare namespace mods="http://www.loc.gov/mods/v3";
(:~
 : This is a sample templating function. It will be called by the templating module if
 : it encounters an HTML element with an attribute data-template="app:test" 
 : or class="app:test" (deprecated). The function has to take at least 2 default
 : parameters. Additional parameters will be mapped to matching request or session parameters.
 : 
 : @param $node the HTML node with the attribute which triggered this call
 : @param $model a map containing arbitrary data - used to pass information between template calls
 :)
declare function app:test($node as node(), $model as map(*)) {
    <p>Dummy template output generated by function app:test at {current-dateTime()}. The templating
        function was triggered by the class attribute <code>class="app:test"</code>.</p>
};

declare 
    %templates:wrap
function app:titles($node as node(), $model as map(*)) as map(*) {
      let $titleSequence :=
        for $rec in collection('/db/bluemtn')//mods:mods[empty(mods:relatedItem[@type='host'])]
        order by upper-case($rec/mods:titleInfo[empty(@type)]/mods:title/string())
        return $rec
    return map { "titles" := $titleSequence }
};

declare
    %templates:wrap
function app:title-label($node as node(), $model as map(*)) {
    let $titleInfo := $model("title")/mods:titleInfo[empty(@type)]
    let $tstring :=
        if ($titleInfo/mods:nonSort)
        then concat($titleInfo/mods:nonSort/string(), " ")
        else ""
    let $tstring := $tstring || $titleInfo/mods:title/string()
    return $tstring
};

declare function local:do-query-old($creator-query as xs:string?, $title-query as xs:string?)
{
    if ($creator-query and $title-query) then
        collection('/db/bluemtn/metadata/periodicals')//mods:relatedItem[ft:query-field("creator", $creator-query) and
            ft:query-field("title", $title-query)]
    else if ($creator-query) then
        collection('/db/bluemtn/metadata/periodicals')//mods:relatedItem[ft:query-field("creator", $creator-query)]
    else if ($title-query) then
        collection('/db/bluemtn/metadata/periodicals')//mods:relatedItem[ft:query-field("title", $title-query)]
    else
        ()
};

declare function local:do-query($creator-query as xs:string?, $title-query as xs:string?)
{
    if ($creator-query and $title-query) then
        collection('/db/bluemtn/metadata/periodicals')//mods:relatedItem[ft:query(mods:name, $creator-query) and
            ft:query-field(mods:titleInfo, $title-query)]
    else if ($creator-query) then
        collection('/db/bluemtn/metadata/periodicals')//mods:relatedItem[ft:query(mods:name, $creator-query)]
    else if ($title-query) then
        collection('/db/bluemtn/metadata/periodicals')//mods:relatedItem[ft:query(mods:titleInfo, $title-query)]
    else
        ()
};

declare function app:query($node as node(), $model as map(*), $creator-query as xs:string?, $title-query as xs:string?) {
    if ($creator-query or $title-query) then
        let $hits :=
            for $hit in local:do-query($creator-query, $title-query)
            order by ft:score($hit) descending
            return <hit><relatedItem>{$hit}</relatedItem><host>{$hit/ancestor::mods:mods}</host></hit>
        return
        (: Process nested templates :)
        map { "hits" := $hits }
    else
        ()
};

(:~
    Create a span with the number of items in the current search result.
:)
declare function app:hit-count($node as node()*, $model as map(*)) {
    <span id="hit-count">{ count($model("hits")) }</span>
};

(:~
    Output the actual search result as a div.
:)
declare 
    %templates:default("start", 1)
function app:show-hits($node as node()*, $model as map(*), $start as xs:integer) {
    <ol class="hit-list"> {
        for $hit at $p in $model("hits")
(:    for $hit at $p in subsequence($model("hits"), $start, 10):)
    let $host := $hit/host
    let $xsl := doc("/db/apps/bmtn_catalog/resources/xsl/entry.xsl")
    
    return
        <li value="{$p}">{ transform:transform($hit/relatedItem, $xsl,() ) }
            <span class="host">{ transform:transform($hit/host, $xsl, ()) }</span>
        </li>
        
    }</ol>

};